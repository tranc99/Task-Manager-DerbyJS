{
  "name": "share",
  "version": "0.7.27",
  "description": "A database for concurrent document editing",
  "keywords": [
    "operational transformation",
    "ot",
    "concurrent",
    "collaborative",
    "database",
    "server"
  ],
  "homepage": "",
  "author": {
    "name": "Joseph Gentle",
    "email": "josephg@gmail.com"
  },
  "dependencies": {
    "livedb": "^0.5.0",
    "ottypes": "~1",
    "hat": "*",
    "async": "~0.2",
    "express": "~3"
  },
  "devDependencies": {
    "coffee-script": "~1.6.3",
    "optimist": ">= 0.2.4",
    "browserchannel": "*",
    "mocha": "~1",
    "uglify-js": "~2"
  },
  "optionalDependencies": {
    "express": "~3"
  },
  "engine": "node >= 0.10",
  "main": "lib/index.js",
  "scripts": {
    "build": "make",
    "prepublish": "make webclient"
  },
  "licenses": [
    {
      "type": "BSD",
      "url": "http://www.freebsd.org/copyright/freebsd-license.html"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/josephg/sharejs.git"
  },
  "bugs": {
    "url": "https://github.com/josephg/sharejs/issues"
  },
  "readme": "ShareJS\n=======\n\nThis is a little server & client library to allow concurrent editing of any\nkind of content via OT. The server runs on NodeJS and the client works in NodeJS or a\nweb browser.\n\nShareJS currently supports operational transform on plain-text and arbitrary JSON data.\n\n**Visit [Google groups](https://groups.google.com/forum/?fromgroups#!forum/sharejs) for discussions and announcements**\n\n**Check out the [live interactive demos](http://sharejs.org/).**\n\n**Immerse yourself in [API Documentation](https://github.com/josephg/ShareJS/wiki).**\n\n[![Build Status](https://secure.travis-ci.org/share/ShareJS.png)](http://travis-ci.org/share/ShareJS)\n\n\nBrowser support\n---------------\n\nShareJS **should** work with all browsers, down to IE5.5 (although IE support\nhasn't been tested with the new version).\n\nThat said, I only test regularly with FF, Safari and Chrome, and occasionally\nwith IE8+. **File bug reports if you have issues**\n\n\nInstalling and running\n----------------------\n\n    # npm install share\n\nRun the example server with:\n\n    # coffee node_modules/share/examples/server.coffee\n\n> Not all of the sharejs 0.6 examples have been ported across yet. I'd love\n> some pull requests!\n\nShareJS depends on [LiveDB](https://github.com/share/livedb) for its database\nbackend & data model. Read the livedb readme for information on how to\nconfigure your database.\n\nRun the tests:\n\n    # npm install\n    # mocha\n\n\n## Server API\n\nTo get started with the server API, you need to do 2 things:\n\n- Decide where your data is going to be stored. You can mess around using\nthe livedb inmemory store. For more options, see the [livedb\napi](https://github.com/share/livedb).\n- Decide how your client and server will communicate. The easiest solution is\nto use [browserchannel](https://github.com/josephg/node-browserchannel).\n\nTo create a ShareJS server instance:\n\n```javascript\nvar livedb = require('livedb');\nvar sharejs = require('share');\n\nvar backend = livedb.client(livedb.memory());\nvar share = require('share').server.createClient({backend: backend});\n```\n\nThe method is called `createClient` because its sort of a client of the\ndatabase... its a weird name, just roll with it.\n\nThe sharejs server instance has 3 methods you might care about:\n\n- To communicate with a client, create a node stream which can communicate with\na client and use **share.listen(stream)** to hand control of the stream to\nsharejs. See the section below on client server communication for an example of\nthis.\n- **share.rest()** returns a connect/express router which exposes the sharejs\nREST API. This code is in the process of moving to its own repo. In the\nmeantime, the [documentation is\nhere](https://github.com/share/rest/blob/master/README.md#exposed-methods)\n- You can intercept requests to the livedb backend to do access control using\nsharejs middleware. **share.use(method, function(action, callback){...})** will\nmake your function intercept & potentially rewrite requests. This is not\ncurrently documented, but when it is, the documentation [will live\nhere](https://github.com/share/middleware/blob/master/README.md).\n\n\n## Client server communication\n\nShareJS requires *you* to provide a way for the client to communicate with the\nserver. As such, its transport agnostic. You can use\n[browserchannel](https://github.com/josephg/node-browserchannel),\n[websockets](https://github.com/einaros/ws), or whatever you like. ShareJS\nrequires the transport to:\n\n- Guarantee in-order message delivery. (**Danger danger socket.io does not guarantee this**)\n- Provide a websocket-like API on the client\n- Provide a node object stream to the server to talk to a client.\n\nWhen a client times out, the server will throw away all information\nrelated to that client. When the client client reconnects, it will reestablish\nall its state on the server again.\n\nIt is the responsibility of the transport to handle reconnection - the client\nshould emit state change events to tell sharejs that it has reconnected.\n\n### Server communication\n\nThe server exposes a method `share.listen(stream)` which you can call with a\nnode stream which can communicate with the client.\n\nHere's an example using browserchannel:\n\n```javascript\nvar Duplex = require('stream').Duplex;\nvar browserChannel = require('browserchannel').server\n\nvar share = require('share').server.createClient({backend: ...});\nvar app = require('express')();\n\napp.use(browserChannel({webserver: webserver}, function(client) {\n  var stream = new Duplex({objectMode: true});\n\n  stream._read = function() {};\n  stream._write = function(chunk, encoding, callback) {\n    if (client.state !== 'closed') {\n      client.send(chunk);\n    }\n    callback();\n  };\n\n  client.on('message', function(data) {\n    stream.push(data);\n  });\n\n  client.on('close', function(reason) {\n    stream.push(null);\n    stream.emit('close');\n  });\n\n  stream.on('end', function() {\n    client.close();\n  });\n\n  // Give the stream to sharejs\n  return share.listen(stream);\n}));\n```\n\nAnd [here](examples/ws.coffee) is a more complete example using websockets.\n\n### Client communication\n\nThe client needs a\n[websocket](https://developer.mozilla.org/en-US/docs/WebSockets)-like session\nobject to communicate. You can use a normal websocket if you want:\n\n```javascript\nvar ws = new WebSocket('ws://' + window.location.host);\nvar share = new sharejs.Connection(ws);\n```\n\nSharejs also supports the following changes from the spec:\n\n- The socket can reconnect. Simply call `socket.onopen` again when the socket\nreconnects and sharejs will reestablish its session state and send any\noutstanding user data.\n- If your underlying API allows data to be sent while in the CONNECTING state,\nset `socket.canSendWhileConnecting = true`.\n- If your API allows JSON messages, set `socket.canSendJSON = true` to avoid\nextra JSON stringifying.\n\nIf you use browserchannel, all of this is done for you. Simply tell\nbrowserchannel to reconnect and it'll take care of everything:\n\n```javascript\nvar socket = new BCSocket(null, {reconnect: true});\nvar share = new sharejs.Connection(socket);\n```\n\n---\n\n## Client API\n\nThe client API can be used either from nodejs or from a browser.\n\nFrom the server:\n\n```javascript\nvar connection = require('share').client.Connection(socket);\n```\n\nFrom the browser, you'll need to first include the sharejs library. You can use\nbrowserify and require('share').client or include the script directly.\n\nThe browser library is built to the `node_modules/share/webclient` directory\nwhen you install sharejs. This path is exposed programatically at\n`require('share').scriptsDir`. You can add this to your express app:\n\n```javascript\nvar sharejs = require('share');\napp.use(express.static(sharejs.scriptsDir));\n```\n\nThen in your web app include whichever OT types you need in your app and sharejs:\n\n```html\n<script src=\"text.js\"></script>\n<script src=\"json0.js\"></script>\n<script src=\"share.js\"></script>\n```\n\nThis will create a global `sharejs` object in the browser.\n\n### Connections\n\nThe client exposes 2 classes you care about:\n\n- The **Connection** class wraps a socket and handles the communication to the\nsharejs server. You use the connection instance to create document references\nin the client.\n- All actual data you edit will be wrapped by the **Doc** class. The document\nclass stores an in-memory copy of the document data with your local edits\napplied.  Create a document instance by calling `connection.get('collection', 'docname')`.\n\n> ShareJS also allows you to make queries to your database. Live-bound queries\nwill return a **Query** object. These are not currently documented.\n\nTo get started, you first need to create a connection:\n\n```javascript\nvar sjs = new sharejs.Connection(socket);\n```\n\nThe socket must be a websocket-like object. See the section on client server\ncommunication for details about how to create a socket.\n\nThe most important method of the connection object is .get:\n\n**connection.get(collection, docname)**: Get a document reference to the named\ndocument on the server. This function returns the same document reference each\ntime you call connection.get(). *collection* and *docname* are both strings.\n\nConnections also expose methods for executing queries:\n\n- **createFetchQuery(index, query, options, callback)**: Executes a query against the backend and returns a set of documents matching the query via the callback.\n- **createSubscribeQuery(index, query, options, callback)**: Run a query against the backend and keep the result set live. Returns a **Query** object via the callback.\n\nThe best documentation for these functions is in a [block comment in the code](https://github.com/share/ShareJS/blob/ff9676d347bd50320c4f1bde080c6b2ae7599333/lib/client/connection.js#L456-L506).\n\nFor debugging, connections have 2 additional properties:\n\n- Set **connection.debug = true** to console.log out all messages sent and\nrecieved over the wire.\n- **connection.messageBuffer** contains the last 100 messages, for debugging\nerror states.\n\n### Documents\n\nDocument objects store your actual data in the client. They can be modified\nsyncronously and they can automatically sync their data with the server.\nDocument objects can be modified offline - they will send data to the server\nwhen the client reconnects.\n\nNormally you will create a document object by calling\n**connection.get(collection, docname)**. Destroy the document reference using\n**doc.destroy()**.\n\nDocuments start in a dumb, inert state. You have three options to get started:\n\n- Normally, you want to call **doc.subscribe(callback)**. This will fetch the\ncurrent data from the server and subscribe the document object to a feed of\nchanges from other clients. (If you don't want to be subscribed anymore, call\n**doc.unsubscribe([callback])**).\n- If you don't want a live feed of changes, call **doc.fetch(callback)** to get\nthe data from the server. Your local document will be updated automatically\nevery time you submit an operation.\n- If you know the document doesn't exist on the server (for example the doc\nname is a new GUID), you can immediately call **doc.create(type, data,\ncallback)**.\n\n> There's a secret 4th option - if you're doing server-side rendering, you can\n> initialize the document object with bundled data by calling\n> **doc.ingestData({type:..., data:...})**.\n\nTo call a method when a document has the current server data, pair your call to\nsubscribe with **doc.whenReady(function() { ... }**. Your function will be\ncalled immediately if the document already has data.\n\nBoth subscribe and fetch take a callback which will be called when the\noperation is complete. In ShareJS 0.8 this callback is being removed - most of\nthe time you should call whenReady instead. The semantics are a little\ndifferent in each case - the subscribe / fetch callbacks are called when the\noperation has completed (successfully or unsuccessfully). Its possible for a\nsubscription to fail, but succeed when the client reconnects. On the other\nhand, whenReady is called once there's data. It will not be called if there was\nan error subscribing.\n\nOnce you have data, you should call **doc.getSnapshot()** to get it. Note that\nthis returns the doc's internal doc object. You should never modify the\nsnapshot directly - instead call doc.submitOp.\n\n#### Editing documents\n\nDocuments follow the [sharejs / livedb object\nmodel](https://github.com/share/livedb#data-model). All documents sort of\nimplicitly exist on the server, but they have no data and no type until you\n'create' them. So you can subscribe to a document before it has been created on\nthe server, and a document on the server can be deleted and recreated without\nyou needing a new document reference.\n\nTo make changes to a document, you can call one of these three methods:\n\n- **doc.create(type, [data], [context], [callback])**: Create the document on\nthe server with the given type and initial data. Type will usually be 'text'\nor 'json0'. Data specifies initial data for the document. For text documents,\nthis should be an initial string. For JSON documents, this should be JSON\nstringify-able data. If unspecified, initial data is an empty string or null\nfor text and JSON, respectively.\n- **doc.submitOp(op, [context], [callback])**: Submit an operation to the\ndocument. The operation must be valid for the given OT type of the document.\nSee the [text document OT\nspec](https://github.com/ottypes/text/blob/master/README.md) and the [JSON\ndocument OT\nspec](https://github.com/ottypes/json0/blob/master/README.md). Consider using a\ncontext instead of calling submitOp directly. (Described below)\n- **doc.del([context], [callback])**: Delete the document on the server. The\ndocument reference will become null.\n\nIn all cases, the `context` argument is a user data object which is passed to\nall event emitters related to this operation. This is designed so data bindings\ncan easily ignore their own events.\n\nThe callback for all editing operations is optional and informational. It will\nbe called when the operation has been acknowledged by the server.\n\nTo be notified when edits happen remotely, register for the 'op' event. (See events section below).\n\nIf you want to pause sending operations to the server, call **doc.pause()**.\nThis is useful if a user wants to edit a document without other people seeing\ntheir changes. Call **doc.resume()** to unpause & send any pending changes to\nthe server.\n\n#### Editing Contexts\n\nThe other option to edit documents is to use a **Document editing context**.\nDocument contexts are thin wrappers around submitOp which provide two benefits:\n\n1. An editing context does not get notified about its own operations, but it\ndoes get notified about the operations performed by other contexts editing\nthe same document. This solves the problem that multiple parts of your app may\nbind to the same document.\n2. Editing contexts mix in API methods for the OT type of the document. This\nmakes it easier to edit the document. Note that the JSON API is currently a\nbit broken, so this is currently only useful for text documents.\n\nCreate a context using **context = doc.createContext()**. Contexts have the\nfollowing methods & properties:\n\n- **context.submitOp(op, callback)**: Wrapper for `doc.submitOp(op, context, callback)`.\n- **context.\\_onOp = function(op) {...}** This is a hook for you / the type API\nto add your own logic when operations happen. If you're using the text API,\nbind to **context.onInsert = ...** and **context.onRemove = ...** instead.\n- **context.destroy()**: Destroy the context. The context will stop getting\nmessages.\n\nIf you're making a text edit binding, bind to a document context instead of\nbinding to the document itself.\n\n\n#### Document events\n\nIn the nodejs tradition, documents are event emitters. They emit the following events:\n\n- **ready**: Emitted when the document has data from the server. Consider using\n**whenReady(callback)** instead of this event so your function is called\nimmediately if the document *already* has data from the server.\n- **subscribe**: Emitted when the document is subscribed. This will be\nre-emitted when the document is resubscribed each time the client reconnects.\n- **unsubscribe**: Emitted when the document is unsubscribed. This will be\nre-emitted whenever the document is unsubscribed due to the client being\ndisconnected.\n- **nothing pending**: Emitted after sending data to the server, when there are\nno outstanding operations to send. Pair with **hasPending** to find out when\nthere is outstanding data. This is useful for displaying \"Are you sure you want\nto close your browser window\" messages to the user.\n\n\n- **create**: Emitted when the document has been created. Called with (context).\n- **del**: Emitted when the document has been deleted. The del event is triggered with (context, oldSnapshot).\n- **before op**: Emitted right before an operation is applied. Called with (op, context).\n- **op**: Emitted right after each part of an operation is applied. Called with\n(op, context). This is usually called just once, but you can specify\n`doc.incremental = true` to tell the document to break the operation into\nsmaller parts and emit them one at a time.\n- **after op**: Emitted after an operation (all of it) is applied. Called with (op, context).\n\nOperations lock the document. For probably bad reasons, it is illegal to call\nsubmitOp in the event handlers for *create*, *del*, *before op* or *op* events. If you\nwant to make changes in response to an operation, register for the *after op* or *unlock* events.\n\n\n#### Examples\n\nHere's some code to get started editing a text document:\n\n```html\n<textarea id='pad' autofocus>Connecting...</textarea>\n<script src=\"channel/bcsocket.js\"></script>\n<script src=\"text.js\"></script>\n<script src=\"share.js\"></script>\n<script>\nvar socket = new BCSocket(null, {reconnect: true});\nvar sjs = new sharejs.Connection(socket);\n\nvar doc = sjs.get('docs', 'hello');\n\n// Subscribe to changes\ndoc.subscribe();\n\n// This will be called when we have a live copy of the server's data.\ndoc.whenReady(function() {\n  console.log('doc ready, data: ', doc.getSnapshot());\n  \n  // Create a JSON document with value x:5\n  if (!doc.type) doc.create('text');\n  doc.attachTextarea(document.getElementById('pad'));\n});\n```\n\nAnd a JSON document:\n\n```javascript\nvar socket = ...;\nvar sjs = new sharejs.Connection(socket);\n\nvar doc = sjs.get('users', 'seph');\n\n// Subscribe to changes\ndoc.subscribe();\n\n// This will be called when we have a live copy of the server's data.\ndoc.whenReady(function() {\n  console.log('doc ready, data: ', doc.getSnapshot());\n  \n  // Create a JSON document with value x:5\n  if (!doc.type) doc.create('json0', {x:5});\n});\n\n// later, add 10 to the doc.snapshot.x property\ndoc.submitOp([{p:['x'], na:10}]);\n```\n\nSee the [examples directory](https://github.com/share/ShareJS/tree/master/examples/public) for more examples.\n\n\n---\n\n# License\n\nShareJS is proudly licensed under the [MIT license](LICENSE).\n\n",
  "readmeFilename": "README.md",
  "_id": "share@0.7.27",
  "_from": "share@^0.7.3"
}
